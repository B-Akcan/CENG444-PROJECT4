   BITS 64
   SECTION .text
   global main
main:
   ; For allocation on stack (prologue)
   push rbp
   mov rbp, rsp
   sub rsp, 4000h
   push r12

   ; For deallocation on stack (epilogue)
   pop r12
   add rsp, 4000h
   mov rsp, rbp
   pop rbp
   ret
   ; This is for exception unwinding return
   mov rsp, rbp
   pop rbp
   ret

   ; Enter and leave instructions
   enter 40000000h, 0
   leave

   ; For double const
   mov rax, __float64__(1.5)
   push rax

   ; For integer const (note: there is no immediate 64 bit push)
   ; We need this only for booleans! Note that each instruction pushes a machine word (qword)
   ; regardless the size of the immediate value.
   push 2h
   push 200h
   push 20000h

   ; For string consts, which are returned by allocstring (lrt 3)
   mov rdi, 0x200000000    ; This is to emulate the string pointer generated by the compiler
   mov rax, 0x400000000    ; This is to emulate the static LRT function in DGEval
   mov r12, rsp            ; r12 is saved across calls
   and rsp, 0fffffffffffffff0h
   call rax
   push rax                ; Return value is in rax
   mov rsp, r12

   ; For insid
   push qword [rbp + 512] ; 512 here represents the calculated ebp based offset of the variable
   push qword [rbp + 520]

   ; For OP_MINUS
   mov rax, 0x8000000000000000
   xor [rsp], rax
   movsd xmm0, [rsp]

   ; For OP_NOT
   mov rax, 1h
   xor [rsp], rax
   movsd xmm0, [rsp]

   ; For OP_BOR and OP_AND
   pop rax
   or [rsp], rax
   and [rsp], rax

   ; For logical operations
   mov rax, [rsp+8]
   or rax, [rsp]
   and rax, [rsp]
   add rsp, 8
   mov [rsp], rax

   ; For arithmetic operations
   movsd xmm0, [rsp+8]
   addsd xmm0, [rsp]
   mulsd xmm0, [rsp]
   divsd xmm0, [rsp]
   subsd xmm0, [rsp]
   comisd xmm0, [rsp]
   add rsp, 8
   movsd [rsp], xmm0

   ; For assign
   mov rax, [rsp]
   mov [rbp+512], rax

   ; For pop n (suppose n*8 is 520)
   add rsp, 520

   ; For popping rax
   pop rax

   mov rdi, rax
   mov rsi, rax
   mov rdx, rax
   mov rcx, rax

   movq xmm0, rax
   movq xmm1, rax
   movq xmm2, rax
   movq xmm3, rax
   movq xmm4, rax
   movq xmm5, rax
   movq xmm6, rax
   movq xmm7, rax

   ; For preparation of the first operand to a call
   mov rdi, [rsp]
   mov rdi, [rsp+8]
   movsd xmm0, [rsp]
   movsd xmm0, [rsp+8]

   ; For preparation of the second operand to a call
   mov rsi, [rsp]
   mov rsi, [rsp+8]
   movsd xmm1, [rsp]
   movsd xmm1, [rsp+8]

   ; For preparation of the third operand to a call
   mov rdx, [rsp]
   mov rdx, [rsp+8]
   movsd xmm2, [rsp]
   movsd xmm2, [rsp+8]

   ; For preparation of the fourth operand to a call
   mov rcx, [rsp]
   mov rcx, [rsp+8]
   movsd xmm3, [rsp]
   movsd xmm3, [rsp+8]

   ; For preparation of the fourth operand to a call
   mov rax, __float64__(1.5)
   movq xmm0, rax
   movq xmm1, rax
   movq xmm2, rax
   movq xmm3, rax


   ; Immediate integral parameters
   mov   rdi, 0x400000000
   mov   rsi, 0x400000000
   mov   rdx, 0x400000000
   mov   rcx, 0x400000000

   ; Pushing return values
   movq rax, xmm0
   push rax

   ; **** Implementing comparison operators
   ; Double precision
   xor rcx, rcx
   add rsp, 16
   movsd xmm0, [rsp-8]
   comisd xmm0, [rsp-16]

   ; Integral type
   pop rdi
   pop rax
   cmp rax, rdi

   ; String comparison (after strcmp returns)
   cmp rax, 0

   ; gt
   jle l1
   inc rcx
l1:
   push rcx

   ; gte
   jl l2
   inc rcx
l2:
   ; lt
   jge l3
   inc rcx
l3:
   ; lte
   jg l4
   inc rcx
l4:
   ; eq
   jne l5
   inc rcx
l5:
   ; neq
   je l6
   inc rcx
l6:
   ; **** Implementing comparison operators ends
   ; Condition evaluation for JT
   pop rax
   or rax, rax
   jnz l1 ; for JT
   jz l1  ; for LF

   ; Calculating array base for allocate array / Elements in reverse order
   mov rcx, rsp

   ; Adding rsp a long value (Used to cleanup the stack for "allocatearray"
   add rsp, 0x40000000

   ; Converting the second parameter of arrayelement
   cvtsd2si rdx, xmm0

